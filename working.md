SSTable：限制2MB 2 *1024 *1024=2097152 bytes

- 32bytes头

  - 时间戳8bytes
  - 数量 long long    8bytes
  - 最小值 8bytes
  - 最大值8bytes

- 10240字节的Bloom Filter (m=10240*8=81920)

- key+offset 每组12bytes

  - key: 8bytes

  - offset:4bytes

    文件大小限制为2097152bytes 可以用int存下

- value:不定长的字符串 多少字符就是多少bytes

设value平均长x字节

数量为$\frac{2097152-32-10240}{12+x}=\frac{2086880}{12+x}$

这里x应该能根据应用的场景事先确定

测试中最大的x是1024 * 64 得到数量为31.8个

最小若取1 得到数量为160529个



跳表中设置p=0.25

最大高度为$log_4(160529)=8.6$

布隆过滤器最小误报率为$k=ln2 \frac{m}{n}$ 

在保存与读取的时候都需要重构一个布隆过滤器 所以不妨让 k也是变量



内存中的跳表每次插入时时刻记录当前大小

记录数量（为了构造布隆过滤器）

与大小（到2m就写入文件）



memTable

SSTable 实现

缓存 实现



缓存存储的内容是除了value之外的所有部分

缓存：

- header 32bytes 直接存结构体
  - 时间戳 8
  - 数量 8
  - 最小键 8
  - 最大键 8
- BloomFilter 10240bytes 直接存类
- IndexList 16*length   用数组的两个好处 1 方便直接存  连续简单  2 方便二分查找直接索引
  - key 8
  - offset 4



待完成：

1. 涉及sstable的scan

2. 如果没有缓存 需要去所有文件里找
3. 文件合并 归并排序
4. 最后一次处理delete





同一个key的数据 可能由于不同时刻的修改  被存入了不同的sstable中

但实际上面向用户的get应该只给出一个结果

所以在get的时候应该按照时间戳由大到小的顺序去查询



由于启动时会加载所有的信息到内存

运行时在保存的同时也会加载到内存

所以只需要关注内存中的保存机制



缓存是有先后顺序的   在查找时应该优先查询后加入的缓存

还是得使用map 需要key(时间戳)作为排序的标志  key越大越前面

如果用字符串排序 10在2前 不行 自定义查找算法插入的时候效率太慢



scan操作 禁止一个个get

对于sstable的索引区和跳表 都可以把连续一段的内容取出来

取出后直接放入堆中

第一个问题 堆排序排序的是key  但是kv的映射关系在出了跳表或sstable就未知了 所以堆要同时保存value的信息 所以需要自定义一个排序函数

第二个问题 如果不同的sstable中存在两个不同的key  应该以时间戳大的为准 但是堆本身并不会进行覆盖

解决方法 堆外套wrapper：

第一种 时间戳由大到小遍历 sstable  如果key已经存在于队列 则不进行push

如果每次遍历队列 复杂度太高 不如新加一个hashtable

第二种 时间戳由小到大遍历sstable key如果存在 则覆盖value

选择第一种





compation：

最多2路归并

理论上上一层可以和下一层所有文件的key相交 所以保存value到内存中不现实 还是只能利用缓存的key去比较 然后seekg拿value

存储容器依旧选择memTable 并且复用函数



0-->1 4路

其他 2路



同时使用两个map容器保存Cache指针  一个根据时间戳排序 一个根据key排序

根据时间戳排序：搜索时先搜索时间戳大的；compaction时只选择最后的

根据key排序：compaction时两路的各自顺序

每一次增删改查都需要同时维护两个map容器

注：维护sstable的文件读写时文件名（时间戳）处理错误，导致文件/缓存不匹配 读取数据时出现极大的问题 这个问题run会出现 而debug不会出现 无法debug 只能肉眼看代码

复用代码时使用类的成员变量传递条件 需要在每个地方都严格进行选择，与维护cache相依赖



一个问题：在合并的时候 timestamp是可以重复的 文件名需要加后缀

同时map需要改成multimap

erase 会全删

解决：erase(find) find后根据path对应



归并：

文件结束 需要换文件

外部声明变量

内部用迭代器换变量



教训：

涉及到文件的操作或stl容器会出现各种不会显式触发的异常

错误原因：文件名冲突，长度读错，没有close，使用没有初始化的变量

错误现象：并不会报任何错，而是会正常运行，测试错误的结果随机，run和debug情况不同，指针异常，跳到不是自己的文件里

1. 开始编程前先把所有的情况想好  严格证明每一步的正确性再开始动手写
2. 写代码的时候小心仔细 复制的时候要记得修改掉不同的变量  索引不能超大小 文件记得关 文件名不能相同
3. 不幸没通过测试后 先找到出错的位置  然后判断逻辑还是代码错 通过debug+cout调试

key相同时，由于归并排序的操作，一定是相邻的，如果先put时间戳小的后put大的，存在的问题是，memtable只剩2，put一个value是1，没超，又put一个delete 超了，会把1直接写入sstable delete存入另一个sstable 两个时间戳一样没法比



对于map<int,shared_ptr<>>的遍历有严重的问题

用引用和不用引用会出现不同的结果 有时候用了会崩溃 有时候不用会崩溃

相关逻辑：用引用的时候shared的usecount不会+1 insert的时候会+1 stl容器会默认进行一份复制 在遍历的时候可以选择使用或不使用引用

